# Задание 1.
Это задание было решено на уровне 1 и уровне 2. Уровень 3 не выполнялся

# Уровень 1. Выбор подхода к декомпозиции фронтенда проекта

## Этап 1. Предварительный анализ
Приложение - это мини соц сеть, где пользователь может выложить фотографии в свой профиль и как-то отреагировать на фото (поставить лайк)
В нем есть несколько логически независимых блоков, такие как профиль, карточки фото, лайки
Приложение написано на react и имеет архитектуру монолита.
Проект также использует технологию Webpack.

Возможная цель перехода - повысить независимость элементов приложения, что позволит 
как выделить независимые команды для работы, так и управять масштабируемостью

Опыт команды - представим, что у нас команда среднего уровня, тк приложение небольшое 
то есть скорее всего написано быстро и дешево, а значит и команда соответствующая.
Но команда точно хочет расти и развиваться, тк потенциально в приложении можно внедрить много разных новых функций
Поэтому команды с амбициями и будет растить экспертизу (с оглядкой на имеющийся опыт)

## Этап 2. Определение бизнес функций с использованием DDD (Domain-Driven Design)
Проведя анализ приложения предлагается выделить следующие микрофронтенды:
1. **Аутентификация**
Трубется для работы с приложением, является критичным, то есть требователен к скорости и надежности
тк это вход в Приложение. Включает в себя компоненты для входа / регистрации, управление токенами и сессией
Сюда относятся функции ```onLogin``` / ```onRegister``` из ```App.js``` и прочие
2. **Профиль пользователя**
В профиле есть фото, описание и имя. 
Ключевой функционал: все поля можно редактировать.
Особенность: главный элемент профиля находится там же, где и галерея, поэтому если смотрим галерею, то и профиль заодно должен прогрузиться
Функции: ```handleUpdateUser``` / ```handleUpdateAvatar``` из ```App.js``` и прочие
3. **Карточки фото**
Ключевой функционал: отображение галереи, добавление новых карточек, удаление карточек
Тут важна реактивность, тк это тот контект, который меняется (добавление / удаление фото)
Функции: ```handleAddPlaceSubmit```- App.js / ```getCardList``` - api.js / ```addCard``` - api.js и прочие
Функции, связанные с лайками: ```handleCardLike``` - App.js / ```changeLikeCardStatus``` - api.js
4. **Host**
Это микрофронтенд, который содержит в себе остальные микрофронтенды, управляет общим состояние приложения, 
включает в себя header и footer.


## Этап 3. Метод реализации

### Инструмент для создания
Проанализировав код проекта, был выбран подход **Webpack Module Federation** по следующим причинам:
1) Проект уже использует Webpack, что обелгчает интеграцию WMF в проект
2) Проект написан на единой технологии - react, это означает, 
что в данный момент неочевидна потребность в использовании разных технологий в проекте (что могло бы склонить в сторону **Single SPA**)
3) Поскольку WMF лучше всего работает при использовании одного фреймворка, то это ровно то, что происходит в этом проекте - используется react
4) Производительность - возможность делить зависимости между микрофронтендами помогает оптимизировать производительность приложения. 
Проанализировав код приложения, можно сказать, что общими зависимостями между микрофронтендами могли бы как минимум выступаить такие библиотеки как ```react``` и ```react-dom``` 

### Метод интеграции микрофронтендов
Учитывая выбранный подход WMF выбран метод объединения - **run-time** 
Причины следующие:
1) Гибкость и независимость. Веб приложение можно поделить на логические части, 
над которыми можно работать независимо (о выбранном разбиении будет написано ниже).
Учитывая то, что приложение - это галерея с профилем, карточками фотографий и социальной частью, 
потенциально каждая из частей может претерпеть значительные изменения в ходе развития проекта в дальнейшем
(и даже добавление нового функционала через микрофронтенды, например, лента рекомендаций как в крупных соц сетях)
Раз в будущем будет требоваться высокая независимость - лучше всего использовать **run-time**
2) Динамическое обновление. В будущем команды будут много работать, чтобы доставлять лучшие фцнкции для пользователей 
Это требует простоты работы и разворачивания, то есть без зависимости от работы других команд
3) Гибкое масштабирование - выглядит так, что некоторые части приложения могут быть менее востребованы (например, профиль), по сравнению с другими частями - карточки / соц. часть с лайками. 
Это дает возможность оптимизировать масштабирование за счет добавления вычислительных мощностей для отдельных микрофронтендов. 
Особенность приложения - профиль одновременно присутствует на странице вместе с галереей, 
это значит, что нужно рассмотреть возможность его предвариетльной сборки, чтобы отдавать всем запросам уже собранный профиль

### Метод компановки
Важные факторы, которые оказали влияние на выбор метода компановки микрофронтендов:
1) Есть интерактивный контент, который меняется в зависимости от действий пользователей (лайки, карточки фото)
Это то, что часто меняется и поэтому их нужно динамически обновлять на клиенте
2) Существуют важные элементы приложения где важна производительность (может быть даже критически важные): 
- Аутентификация и авторизация - позволяет получить доступ к приложению, это буквально точка входа
Для того, чтобы пользователь остался в приложении, мы должны обеспечить высокую производительность,
тк ждать в самом начале никто не любит :)
- Профиль пользователя - менее востребовання часть приложения, может быть собрана заранее на сервере.
Учитывая то, что профиль виден совместно с галереей, потенциально мы можем выйграть в производительности,
если будем собирать его один раз на сервере и отдавать потом массово всем
3) В будущем возможно появятся менее требовательные к производительности элементы, 
такие вещи как уведомления - они могут загружаться асинхронно на клиенте

Итого, учитывая требование к приложению, вы выбираем метод гибридной композиции, 
аутентификация и профиль пользователя - формируем на серверее и ускоряем работу,
остальные элементы - загружаем на клиенте


# Уровень 2. Декомпозиция фронтенда на микроферонтенды
Было проработано разбиение директории frontend на микрофронтенды с выделением 4 микроферонтендов:
1) **authentification** - Аутентификация

frontend/microfrontend/authentification/
├── src/
│   ├── App.js                    # Основное приложение с логикой авторизации
│   ├── components/
│   │   ├── InfoTooltip.js        # Компонент для оторбажения статуса сообщения по авторизации
│   │   ├── Login.js              # Форма логина
│   │   ├── Register.js           # Форма регистрации
│   │   └── ProtectedRoute.js     # Роутер для маршрута авторизации
│   ├── utils/
│   │   └── auth.js               # API вутентификации и управление токенами
│   ├── blocks/
│   │   │── auth-form/            # Стили для авторизации
│   │   │   ├── auth-form.css
│   │   │   ├── __button/
│   │   │   ├── __form/
│   │   │   ├── __input/
│   │   │   ├── __link/
│   │   │   ├── __text/
│   │   │   ├── __textfield/
│   │   │   ├── __title/
│   │   │   └── auth-form.css
│   │   └── login/
│   │       └── login.css         
│   ├── contexts/
│   │   └── CurrentUserContext.js  # Юзер контекст для авторизации
│   ├── index.js                   # Точка входа
│   └── index.css                  # Основные стили
└── package.json                   # Зависимости

2) **photo-cards** - Карточка фото

frontend/microfrontend/photo-cards/
├── src/
│   ├── App.js                    # Основное приложение с логикой
│   ├── components/
│   │   ├── Card.js               # Компонент карточки с фото
│   │   ├── ImagePopup.js         # Попап для просмотра фото
│   │   ├── AddPlacePopup.js      # Попап добавления новой карточки
│   │   └── PopupWithForm.js      # Базовый компонент для попапов
│   ├── blocks/
│   │   ├── card/                 # Стили для карточки
│   │   │   ├── card.css
│   │   │   ├── __description/
│   │   │   ├── __image/
│   │   │   ├── __title/
│   │   │   ├── __like-button/
│   │   │   │   └── _is-active/
│   │   │   ├── __like-count/
│   │   │   └── __delete-button/
│   │   │       ├── _hidden/
│   │   │       └── _visible/
│   │   ├── places/              # Стили для галереи карточек
│   │   │   ├── places.css
│   │   │   ├── __list/
│   │   │   └── __item/
│   │   └── popup/               # Стили для попапов
│   │       ├── popup.css
│   │       ├── __content/
│   │       ├── __close/
│   │       ├── __error/
│   │       ├── __icon/
│   │       ├── __label/
│   │       ├── __status-message/
│   │       ├── __title/
│   │       ├── __form/
│   │       ├── __input/
│   │       ├── __button/
│   │       ├── __caption/
│   │       ├── __image/
│   │       ├── __type/
│   │       └── _is-opened/
│   ├── contexts/
│   │   └── CurrentUserContext.js # Контекст для проверки владельца карточки
│   ├── utils/
│   │   └── api.js                # API для работы с карточками
│   ├── index.js                  # Точка входа
│   └── index.css                 # Основные стили
└── package.json                  # Зависимости


3) **user-profile** - профиль пользователя

frontend/microfrontend/user-profile/
├── src/
│   ├── App.js                    # Основное приложение с логикой
│   ├── components/
│   │   ├── EditProfilePopup.js   # Попап редактирования профиля
│   │   ├── EditAvatarPopup.js    # Попап обновления аватара
│   │   └── PopupWithForm.js      # Базовый компонент для попапов
│   ├── blocks/
│   │   └── profile/              # Стили для профиля
│   │       ├── profile.css
│   │       ├── __description/    # Стили для описания профиля
│   │       ├── __title/          # Стили для имени пользователя
│   │       ├── __image/          # Стили для аватара
│   │       ├── __info/           # Стили для информации профиля
│   │       ├── __edit-button/    # Стили для кнопки редактирования
│   │       └── __add-button/     # Стили для кнопки добавления
│   ├── contexts/
│   │   └── CurrentUserContext.js # Контекст с данными пользователя
│   ├── utils/
│   │   └── api.js                # API для работы с данными пользователя
│   ├── index.js                  # Точка входа 
│   └── index.css                 # Основные стили
└── package.json                  # Зависимости с react и react-dom

4) **host** Хост приложение - контейнер для остальных микрофронтендов

frontend/microfrontend/host/
├── src/
│   ├── App.js                    # Основное приложение с логикой
│   ├── components/
│   │   ├── Header.js             # Хэдер с навигацией
│   │   ├── Footer.js             # Футер
│   │   ├── Main.js               # Основной контейнер
│   ├── blocks/
│   │   ├── header/               # стили Хэдера
│   │   │   ├── header.css
│   │   │   ├── __logo/
│   │   │   ├── __auth-link/
│   │   │   ├── __wrapper/
│   │   │   ├── __user/
│   │   │   └── __logout/
│   │   ├── footer/               # Стили футера
│   │   │   ├── footer.css
│   │   │   └── __copyright/
│   │   ├── page/                 # Стили страницы
│   │   │   ├── page.css
│   │   │   ├── __content/
│   │   │   └── __section/
│   │   └── content/              # Стили контента
│   │       └── content.css
│   ├── contexts/
│   │   └── CurrentUserContext.js # Юзер контекст
│   ├── utils/
│   │   └── api.js                # API 
│   ├── index.js                  # Точка входа
│   ├── index.css                 # Основные стили
│   ├── logo.svg                  
│   ├── serviceWorker.js                    
│   └── setupTests.js             
├── public/
│   └── index.html                # HTML шаблон
│   └── favicon.ico
│   └── logo192.png
│   └── logo512.png
│   └── manifest.json
│   └── robots.txt
└── package.json                  # Зависимости

5) Хранение изображений, иконок, шрифтов
Также, дополнительно была выделена папка ```static``` для хранения изображений, иконок и шрифтов
Стоит сказать, что картинки с сайта, которые загрузил пользователь хранить в таком виде - сильно неправильно!
Для хранения пользовательской информации больше подходит специализированная база данных (например MongoDB)



# Задание 2

Ссылка на итоговую схему: https://drive.google.com/file/d/1s4a6qQbUEQjya9K8j6HyoJYji3mYRIFE/view?usp=sharing

## Объяснение решения
Проведя анализ с помощью DDD были выявлены бизнес процессы, проведя разеделение по ним архитектуры приложения, получились следующие сервисы:

### Сервисы на Django:
1) **Регистрация / аутентификация**
Все что связано с регистрацией и аутентификацией
2) **Работа с обращениями**
Сюда входит как работа с апеляциями, так и работа с обращениями в техподдержку,
тк по сути это одни и те же операции, просто отличается тематика обращений
3) **Каталог**
Все что связано с CRUD товаров и услуг, просмотром товаров / услуг, их поиском
4) **Аукционы**
CRUD + заявки на акцион, ставки и статусы
5) **Заказы**
CRUD + работа с заказами.
6) **Оплаты**
Все что связано с проведением оплат + работа с внешними партнерскими сервисами
7) **Аналитика**
Поскольку аналитические отчеты вроде отчета по активности пользователей, статистика заказов и отчеты по продажам требуют значительных вычислительных ресурсов (требуется ресурсоемкая аггрегация данных)
В схему приложения была добавлена аналитическая база Clickhouse, которая заточена под работу с аналитикой (тк база колончатая)
А также Airflow для перелива данных из баз данных прочих сервисов в базу Clickhouse. Это процесс ETL, который нужно запускать с некоторой периодичностью (например, раз в сутки),
чтобы аналитические отчеты можно было формировать с информацией на "вчера"

### Сервисы на React
Также, в оригинальном монолитном приложении было одно React приложение,
его также стоит разделить на несколько микрофронтендов:
1) **Регистрация и профиль пользователя** 
2) **Каталог товаров и услуг**
Не смотря на то, что на django есть функции, связанные с просмотром карточек, поиском, фильтрацией, изменением карточек,
было решено добавить react приложение для просмотра каталога, так как из схемы оригинального монолита не очевидно, что есть именно каталог, который можно просматривать (со многими товарами)
То есть словно бы можно поискать конкретные товары, то посмотреть что-то по категории (как на маркетплейсах) - такого нет, поэтому добавлен этот компонент
3) **Управление аукционами**
4) **Размещение заказов / услуг**

### Маршрутизация
Поскольку приложение разделено на микросервисы, появилась потребность в маршрутизации запросов, поэтому был добавлен блок "Маршрутизация запросов"
В качестве маршрутизатора можно использовать например Njinx

### Взаимодействие сервисов
В приложении явно существует этапность работы с микросервисами, что вызывает осложнение в виде необходимости консистентности данных
Например, процесс требующий такой консистентности является:
Размещение товара -> заказ товара -> оплата товара
При неуспешной отмене оплаты или отмене заказа, вся цепочка должна придти к одному состоянию данных
Для этого в приложении будет использоваться паттерн SAGA с хореографией
Для этого сервис заказа должен забронировать товар / услугу в сервисе Каталога,
затем при переходе к сервису оплат передается информация на оплату
При успешной оплате статус меняется на оплачено
Если оплата отменена / не прошла, то информацию возвращается в сервис заказов и он отменяет бронирование товара / услуги в каталоге (то есть в обратную сторону идет информация)
На схеме SAGA с хореографией - это потоки 11 / 12 / 8 / 7 + потоки с внешними сервисами
